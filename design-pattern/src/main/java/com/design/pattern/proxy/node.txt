代理模式
在代理模式(Proxy pattern)中，一个类代表另一个类的功能。这种类型的设计模式属于结构模式。
在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。
介绍
意图：为其他对象提供一种代理以控制对这个对象的访问。
主要解决：在直接访问对象时带来的问题，比如说：在面向对象系统中，由些对象由于某些原因（
比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用
者或者系统带来很多麻烦，我们在访问此对象时加上一个对此对象的访问层。
如何使用：想在访问一个类时做一些控制
如何解决：增加中间层
关键代码：实现与被被代理类组合
优点：职责清晰，高拓展性，智能化
缺点：由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能造成请求的处理
速度变慢
为什么要使用代理模式？
1.中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以
在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。
2.开闭原则，增加功能：可以通过代理类增加额外的功能来拓展委托类的功能，这样我们只需要修改
代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤
消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是通过
调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功
能执行的前后加入一些公共的服务。例如想给项目加入缓存、日志的功能。

有几种代理模式？
按照代理创建的时期来进行分类的话，可以分为静态代理和动态代理。静态代理是由程序员创建或特定
工具自动生成源代码，再对其编译，在程序运行之前，代理类.class文件就已经被创建了。动态代理
是程序运行时通过反射机制由JDK动态创建的。

静态代理
优点：可以做到在符合开闭原则的情况下对目标对象进行功能拓展
缺点：得为每一个服务都创建代理类，工作量太大，不易管理，且接口一旦发生改变，代理类也要修改。


JDK动态代理
相对于静态代理，动态代理大大减少了开发任务且减少了对业务接口的依赖，降低了耦合度，但是还有些
不足之处，那就时始终无法摆脱仅支持interface代理的桎梏，因为它的设计就注定了这个遗憾。那些
动态代理生成的代理类都会继承一个父类Proxy类，而Java是单继承的。

CGLIB代理
JDK实现动态代理是需要实现类通过接口定义业务方法，对于没有接口的类，可以使用CGLIB。CGLIB采用
了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术
拦截所有父类方法的调用，顺势织入横切逻辑。但因采用的是继承，所以不能对final修饰的类进行代理。
JDK动态代理和CGLIB动态代理均是实现Spring AOP的基础。CGLIB创建的动态代理对象比JDK创建的动态
代理对象的性能更高，但是CGLIB创建代理对象时花费的时间却比JDK多的多。所以对于单例的对象，因为
无需频繁创建对象，用CGLIB合适，反之使用JDK方式更为合适一些。由于CGLIB的大部分类是直接对Java
字节码进行操作，这样生成的的类会在Java的永久堆中，，如果动态代理操作过多，容易造成永久堆满，
触发OutOfMemory异常。Spring默认使用JDK动态代理，如果类没有接口，则使用CGLIB。
